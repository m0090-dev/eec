
//
//
/*
// Run executes the previous run() logic but returns errors instead of os.Exit.
func (e *Engine) Run(ctx context.Context,opts types.RunOptions) error {

	var err error
	// -----------------------
	// 開始時環境変数表示*/
	// -----------------------
	{
		envs := e.Env().Environ()
		envStr := strings.Join(envs, ", ")
		e.Logger.Debug().Str("Started envs", envStr).Msg("")
	}

	e.Logger.Debug().Str("config file", opts.ConfigFile).Str("program", opts.Program).
		Strs("Program args", opts.ProgramArgs).Str("tag", opts.Tag).Strs("imports", opts.Imports).Int("Wait timeout", int(opts.WaitTimeout)).Bool("Hide window", opts.HideWindow).Str("Deleter path", opts.DeleterPath).Bool("Deleter hide window", opts.DeleterHideWindow).Msg("Run called")

	// ----------------------*/
	// deleter起動
	// ----------------------*/
	deleterPath := opts.DeleterPath
	deleterHideWindow := opts.DeleterHideWindow

	if deleterPath == "" || !e.FS().FileExists(deleterPath) {
		deleterPath = filepath.Join(types.DEFAULT_DELETER_EXECUTE_NAME)
	}

	// Start process
	running, err := domain.IsProcessRunning(e.OS, e.Logger, types.DEFAULT_DELETER_EXECUTE_NAME)
	if err != nil {
		e.Logger.Error().Err(err).Msg("failed to check process")
		return fmt.Errorf("failed to check process: %w", err)
	}

	if running {
		e.Logger.Debug().Msgf("[%s] は既に実行中です", deleterPath)
	} else {
		e.Logger.Debug().Msgf("[%s] を起動します...", deleterPath)
		var pid int
		//var proc *gos.Process
		//var cmd *exec.Cmd
		var err error

		if runtime.GOOS == "windows" {
			// Windows
			var out, errOut *gos.File
			if !deleterHideWindow {
				// 表示する場合のみ Console を繋ぐ
				out, errOut = e.Console().Stdout(), e.Console().Stderr()
			}

			pid, _, _, err = e.Executor().StartProcessWithCmd(
				deleterPath,
				[]string{}, // 引数なし
				e.Env().Environ(),
				nil,               // stdin は使わない
				out,               // stdout
				errOut,            // stderr
				deleterHideWindow, // HideWindow フラグ
			)
		} else {
			// Linux / macOS
			var out, errOut *gos.File
			if !deleterHideWindow {
				// 通常モードは Console に接続
				out, errOut = e.Console().Stdout(), e.Console().Stderr()
			}
			pid, _, _, err = e.Executor().StartProcessWithCmd(
				deleterPath,
				[]string{}, // 引数なし
				e.Env().Environ(),
				nil,               // stdin
				out,               // stdout
				errOut,            // stderr
				deleterHideWindow, // nohup 相当かどうか
			)
		}

		if err != nil {
			e.Logger.Error().Err(err).Msg("failed to start process")
			return fmt.Errorf("failed to start process: %w", err)
		}
		e.Logger.Info().Msgf("deleter started (pid=%d)", pid)
	}

	// Read tag data if provided
	var tagData types.TagData
	if opts.Tag != "" {
		tagData, err = types.ReadTagData(e.OS, e.Logger, opts.Tag)
		if err != nil {
			e.Logger.Error().Err(err).Str("tag", opts.Tag).Msg("failed to read tag")
			return fmt.Errorf("failed to read tag %s: %w", opts.Tag, err)
		}
	}

	// Resolve configFile / program / args with same precedence as original:
	configFile := opts.ConfigFile
	program := opts.Program
	pArgs := opts.ProgramArgs

	if opts.Tag != "" {
		if tagData.ConfigFile != "" {
			configFile = tagData.ConfigFile
		}
		if tagData.Program != "" {
			program = tagData.Program
		}
		if len(tagData.ProgramArgs) != 0 {
			pArgs = tagData.ProgramArgs
		}
	}

	// Flag override (already reflected by opts values); keep the same logic as original:
	// If opts.ConfigFile / Program / ProgramArgs provided they override previous values.
	if opts.ConfigFile != "" {
		configFile = opts.ConfigFile
	}
	if opts.Program != "" {
		program = opts.Program
	}
	if len(opts.ProgramArgs) != 0 {
		pArgs = opts.ProgramArgs
	}

	// Load main config if exists
	var config types.Config
	if configFile != "" && e.FS().FileExists(configFile) {
		if config, err = types.ReadConfig(e.OS, e.Logger, configFile); err != nil {
			e.Logger.Error().Err(err).Str("configFile", configFile).Msg("failed to read config")
			return fmt.Errorf("failed to read config %s: %w", configFile, err)
		}
	}

	// Fill from config if program missing
	if (opts.Tag == "" || tagData.Program == "") && config.Program.Path != "" && program == "" {
		program = config.Program.Path
	}
	if (opts.Tag == "" || len(tagData.ProgramArgs) == 0) && len(config.Program.Args) != 0 && len(pArgs) == 0 {
		pArgs = config.Program.Args
	}

	// build manifest/temp prefix
	selfProgram := e.CommandLine().Args()[0]
	tmpDir := e.FS().TempDir()
	if tmpDir == "" {
		tmpDir = e.FS().TempDir()
	}
	tmpPrefix := fmt.Sprintf("%s_%s_%s.tmp",
		general.RemoveExtension(filepath.Base(selfProgram)),
		general.RemoveExtension(filepath.Base(program)),
		uuid.New().String(),
	)
	tmpPath := filepath.Join(tmpDir, tmpPrefix)
	tmpFile, err := e.FS().Create(tmpPath)
	if err != nil {
		e.Logger.Error().Err(err).Str("prefix", tmpPrefix).Msg("failed to create temp file")
		return fmt.Errorf("failed to create temp file: %w", err)
	}
	defer tmpFile.Close()
	e.Logger.Info().Str("tempFile", tmpPath).Msg("created temp file")

	manifest := types.Manifest{
		TempFilePath: tmpFile.Name(),
		EECPID:       e.Executor().Getpid(),
	}
	manifestPath, err := manifest.WriteToManifest()
	if err != nil {
		e.Logger.Error().Err(err).Str("manifestPath", manifestPath).Msg("failed to write manifest")
		return fmt.Errorf("failed to write manifest: %w", err)
	}
	e.Logger.Info().Str("manifest", manifestPath).Msg("created manifest")

	// Merge envs (imports -> tag imports -> main config)
	allConfigs := []types.Config{}

	// imports from opts
	for _, imp := range opts.Imports {
		cfg, rerr := domain.ReadOrFallback(e.OS, e.Logger, imp)
		if rerr == nil {
			allConfigs = append(allConfigs, cfg)
		} else {
			// ignore missing import: keep behavior consistent with original
			e.Logger.Debug().Err(rerr).Str("import", imp).Msg("import skipped")
		}
	}

	// tag imports
	for _, imp := range tagData.ImportConfigFiles {
		cfg, rerr := domain.ReadOrFallback(e.OS, e.Logger, imp)
		if rerr == nil {
			allConfigs = append(allConfigs, cfg)
		} else {
			e.Logger.Debug().Err(rerr).Str("import", imp).Msg("tag import skipped")
		}
	}

	// main config last
	allConfigs = append(allConfigs, config)

	// start with current environ
	finalEnv := e.Env().Environ()
	for _, cfg := range allConfigs {
		finalEnv = cfg.BuildEnvs(e.OS, e.Logger, finalEnv)
	}

	// Debug prints similar to original
	for _, eStr := range finalEnv {
		if strings.HasPrefix(strings.ToUpper(eStr), "PATH=") {
			e.Logger.Debug().Str("Final PATH", eStr).Msg("path check")
		}
	}
	//e.Logger.Debug().Str("LookPath PATH", os.Getenv("PATH")).Msg("")

	// resolve executable
	if program == "" {
		return errors.New("no program specified")
	}
	
	//	progPath, err := e.Executor.LookPath(program)
//		if err != nil {
//			e.Logger.Error().Err(err).Str("program", program).Msg("executable not found")
//			return fmt.Errorf("executable not found: %w", err)
//		}
	

	// Start process
	childPid, proc, err := e.Executor().StartProcess(program, pArgs, finalEnv, e.Console().Stdin(), e.Console().Stdout(), e.Console().Stderr(), opts.HideWindow)
	if err != nil {
		e.Logger.Error().Err(err).Msg("failed to start process")
		return fmt.Errorf("failed to start process: %w", err)
	}
	e.Logger.Info().Int("PID", childPid).Msg("sub process started")

	// write tempData
	tempData := types.TempData{
		ParentPID:   e.Executor().Getpid(),
		ChildPID:    childPid,
		ConfigFile:  configFile,
		Program:     program,
		ProgramArgs: pArgs,
	}
	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	if err := enc.Encode(tempData); err != nil {
		e.Logger.Error().Err(err).Msg("failed to encode temp data")
		// attempt to stop child process if possible
		_ = proc.Kill()
		return fmt.Errorf("failed to encode temp data: %w", err)
	}
	if _, err := tmpFile.Write(buf.Bytes()); err != nil {
		e.Logger.Error().Err(err).Msg("failed to write temp file")
		_ = proc.Kill()
		return fmt.Errorf("failed to write temp file: %w", err)
	}
	e.Logger.Info().
		Int("ParentPID", tempData.ParentPID).
		Int("ChildPID", tempData.ChildPID).
		Str("ConfigFile", tempData.ConfigFile).
		Str("Program", tempData.Program).
		Strs("ProgramArgs", tempData.ProgramArgs).
		Msg("temp file written")

	// Wait for process (with optional timeout)
	if err := e.Executor().WaitProcess(proc, opts.WaitTimeout); err != nil {
		e.Logger.Error().Err(err).Msg("process finished with error or wait failed")
		return fmt.Errorf("process wait error: %w", err)
	}
	// -----------------------*/
	// 終了時環境変数表示*/
	// -----------------------*/
	{
		envs := e.Env().Environ()
		envStr := strings.Join(envs, ", ")
		e.Logger.Debug().Str("Finished envs", envStr).Msg("")
	}

	e.Logger.Info().Msg("process finished normally")
	return nil
}
*/




func (e *Engine) Run(ctx context.Context, opts types.RunOptions) error {
	var err error

	// -----------------------*/
	// 開始時環境変数表示
	// -----------------------*/
	envs := e.Env().Environ()
	e.Logger.Debug().Str("Started envs", strings.Join(envs, ", ")).Msg("")

	e.Logger.Debug().
		Str("config file", opts.ConfigFile).
		Str("program", opts.Program).
		Strs("Program args", opts.ProgramArgs).
		Str("tag", opts.Tag).
		Strs("imports", opts.Imports).
		Int("Wait timeout", int(opts.WaitTimeout)).
		Bool("Hide window", opts.HideWindow).
		Str("Deleter path", opts.DeleterPath).
		Bool("Deleter hide window", opts.DeleterHideWindow).
		Msg("Run called")

	// -----------------------*/
	// deleter起動
	// -----------------------*/
	if err := domain.LaunchDeleter(e.OS, e.Logger, opts); err != nil {
		return err
	}

	// ----------------------*/
	// タグデータ読み込み
	// -----------------------*/
	var tagData types.TagData
	if opts.Tag != "" {
		tagData, err = types.ReadTagData(e.OS, e.Logger, opts.Tag)
		if err != nil {
			e.Logger.Error().Err(err).Str("tag", opts.Tag).Msg("failed to read tag")
			return fmt.Errorf("failed to read tag %s: %w", opts.Tag, err)
		}
	}

	// ----------------------*/
	// メイン config 読み込み
	// -----------------------*/
	var config types.Config
	if opts.ConfigFile != "" && e.FS().FileExists(opts.ConfigFile) {
		config, err = types.ReadConfig(e.OS, e.Logger, opts.ConfigFile)
		if err != nil {
			e.Logger.Error().Err(err).Str("configFile", opts.ConfigFile).Msg("failed to read config")
			return fmt.Errorf("failed to read config %s: %w", opts.ConfigFile, err)
		}
	}

	// ----------------------*/
	// ResolveRunOptions 呼び出し
	// -----------------------*/
	configFile, program, pArgs, finalEnv := domain.ResolveRunOptions(opts, tagData, config, e.OS, e.Logger)
	if program == "" {
		return errors.New("no program specified")
	}

	// ----------------------*/
	// build temp file
	// -----------------------*/
	selfProgram := e.CommandLine().Args()[0]
	tmpDir := e.FS().TempDir()
	tmpPrefix := fmt.Sprintf("%s_%s_%s.tmp",
		general.RemoveExtension(filepath.Base(selfProgram)),
		general.RemoveExtension(filepath.Base(program)),
		uuid.New().String(),
	)
	tmpPath := filepath.Join(tmpDir, tmpPrefix)
	tmpFile, err := e.FS().Create(tmpPath)
	if err != nil {
		e.Logger.Error().Err(err).Str("prefix", tmpPrefix).Msg("failed to create temp file")
		return fmt.Errorf("failed to create temp file: %w", err)
	}

	e.Logger.Info().Str("tempFile", tmpPath).Msg("created temp file")
	
	// manifest 書き込み
	manifest := types.Manifest{
		TempFilePath: tmpPath,
		EECPID:       e.Executor().Getpid(),
	}
	if _, err := manifest.WriteToManifest(); err != nil {
		return fmt.Errorf("failed to write manifest: %w", err)
	}

	// ----------------------*/
	// Start process
	// -----------------------*/
	var childPid int
	if opts.Pty {
		// PTY専用
		var cmd *pty.Cmd
		if e.PtyData.P == nil {
			cmd, p, err := e.Executor().StartProcessPty(program, pArgs)
			if err != nil {
				tmpFile.Close()
				return fmt.Errorf("failed to start process with pty: %w", err)
			}
			e.PtyData = types.PtyData{P: p, Cmd: cmd}

			// PTY 入出力接続
			go func() { _, _ = io.Copy(e.PtyData.P, e.Console().Stdin()) }()
			go func() { _, _ = io.Copy(e.Console().Stdout(), e.PtyData.P) }()
		} else {
			cmd, err = e.Executor().RestartProcessPty(e.PtyData.P, program, pArgs)
			if err != nil {
				tmpFile.Close()
				return fmt.Errorf("failed to restart process with pty: %w", err)
			}
			e.PtyData.Cmd = cmd
		}
		childPid = e.PtyData.Cmd.Process.Pid

		e.Logger.Info().Int("PTY PID", childPid).Msg("PTY sub process started")

		if err := e.Executor().WaitProcess(e.PtyData.Cmd.Process, opts.WaitTimeout); err != nil {
			tmpFile.Close()
			return fmt.Errorf("PTY process wait error: %w", err)
		}
	} else {
		// 通常プロセス
		var cmd *exec.Cmd
		cmd, err = e.Executor().StartProcess(program, pArgs, finalEnv,
			e.Console().Stdin(), e.Console().Stdout(), e.Console().Stderr(), opts.HideWindow)
		if err != nil {
			tmpFile.Close()
			return fmt.Errorf("failed to start process: %w", err)
		}
		childPid = cmd.Process.Pid

		e.Logger.Info().Int("PID", childPid).Msg("normal sub process started")

		if err := e.Executor().WaitProcess(cmd.Process, opts.WaitTimeout); err != nil {
			tmpFile.Close()
			return fmt.Errorf("process wait error: %w", err)
		}
	}

	// ----------------------*/
	// write tempData
	// -----------------------*/
	tempData := types.TempData{
		ParentPID:   e.Executor().Getpid(),
		ChildPID:    childPid,
		ConfigFile:  configFile,
		Program:     program,
		ProgramArgs: pArgs,
		Pty:         opts.Pty,
	}
	var buf bytes.Buffer
	if err := gob.NewEncoder(&buf).Encode(tempData); err != nil {
		tmpFile.Close()
		return fmt.Errorf("failed to encode temp data: %w", err)
	}
	if _, err := tmpFile.Write(buf.Bytes()); err != nil {
		tmpFile.Close()
		return fmt.Errorf("failed to write temp file: %w", err)
	}

	// **ここで必ず Close()**
	if err := tmpFile.Close(); err != nil {
		return fmt.Errorf("failed to close temp file: %w", err)
	}

	// -----------------------*/
	// 終了時環境変数表示
	// -----------------------*/
	envs = e.Env().Environ()
	e.Logger.Debug().Str("Finished envs", strings.Join(envs, ", ")).Msg("")
	e.Logger.Info().Msg("process finished normally")
	return nil
}








/*func add(args[] string){*/
	/*tagName := args[0]*/
		/*// -- デバッグ用 --*/
		/*log.Debug().*/
			/*Str("tagName", tagName).*/
			/*Msg("")*/
		/*log.Debug().*/
			/*Str("configFileFlag", configFileTagFlag).*/
			/*Msg("")*/
		/*log.Debug().*/
			/*Str("programFlag", programTagFlag).*/
			/*Msg("")*/
		/*log.Debug().*/
			/*Str("programArgsFlag", strings.Join(programArgsTagFlag, ", ")).*/
			/*Msg("")*/
		/*log.Debug().*/
			/*Str("Import config files", strings.Join(importConfigFilesTagFlag, ", ")).*/
			/*Msg("")	*/
		/*//*/

		/*data := ext.TagData{*/
			/*ConfigFile:  configFileTagFlag,*/
			/*Program:     programTagFlag,*/
			/*ProgramArgs: programArgsTagFlag,*/
			/*ImportConfigFiles: importConfigFilesTagFlag,*/
		/*}*/
		/*if err := data.Write(tagName); err != nil {*/
			/*log.Error().Err(err).Msg("タグファイルの書き込みに失敗しました")*/
			/*os.Exit(1)*/
		/*}*/
		/*fmt.Println("Tag added:", tagName)*/

/*}*/


/*func read(args[] string){*/
	/*tagName := args[0]*/
		/*data, err := ext.ReadTagData(tagName)*/
		/*if err != nil {*/
/*log.Error().Err(err).Msg("タグファイルの読み込みに失敗しました")*/
			/*os.Exit(1)*/
		/*}*/
		/*fmt.Printf("Tag: %s\n  Config: %s\n  Program: %s\n  Args: %v\n  Import config files: %v\n",*/
			/*tagName, data.ConfigFile, data.Program, data.ProgramArgs,data.ImportConfigFiles)*/

/*}*/


/*func list(args[] string){*/
	/*homeDir, err := os.UserHomeDir()*/
		/*if homeDir == "" {*/
			/*log.Error().Err(err).Msg(fmt.Sprintf("homeDir(%s)が設定されていません", homeDir))*/
			/*os.Exit(1)*/
		/*}*/
		/*tagDir := filepath.Join(homeDir, ext.DEFAULT_TAG_DIR)*/
		/*fileLists, err := general.GetFilesWithExtension(tagDir, ".tag")*/
		/*if err != nil {*/
			/*log.Error().Err(err).Msg("タグファイルが見つかりませんでした")*/
			/*os.Exit(1)*/
		/*}*/
		/*fmt.Printf("-- current tag lists  --\n")*/
		/*fmt.Printf("%s\n", strings.Join(fileLists, "\n"))*/
/*}*/

/*func remove(args[] string){*/
	/*tagName := args[0]*/
		/*homeDir, err := os.UserHomeDir()*/
		/*if homeDir == "" {*/
			/*log.Error().Err(err).Msg(fmt.Sprintf("homeDir(%s)が設定されていません", homeDir))*/
			/*os.Exit(1)*/
		/*}*/
		/*tagDir := filepath.Join(homeDir, ext.DEFAULT_TAG_DIR)*/
		/*tagPath := filepath.Join(tagDir, fmt.Sprintf("%s.tag", tagName))*/
		/*err = os.Remove(tagPath)*/
		/*if err != nil {*/
			/*log.Error().Err(err).Msg(fmt.Sprintf("タグ名: %sの削除に失敗しました", tagName))*/
			/*os.Exit(1)*/
		/*}*/
		/*fmt.Printf("タグ名: %sを削除しました\n", tagName)*/
	
		/*fileLists, err := general.GetFilesWithExtension(tagDir, ".tag")*/
		/*if err != nil {*/
			/*log.Error().Err(err).Msg("タグファイルが見つかりませんでした")*/
			/*os.Exit(1)*/
		/*}*/
		/*fmt.Printf("-- current tag lists  --\n")*/
		/*fmt.Printf("%s\n", strings.Join(fileLists, "\n"))*/

/*}*/



/*func (c *Config) ApplyEnvs() error {*/

/*// -- OSごとの区切り文字分岐 --*/
/*var separator string*/
/*if runtime.GOOS == "windows" {*/
/*separator = ";" // Windowsではセミコロン*/
/*} else {*/
/*separator = ":" // Unix/Linux/macOSではコロン*/
/*}*/

/*currentPaths := strings.Split(os.Getenv("PATH"), separator)*/
/*for _, env := range c.Envs {*/
/*key := env.Key*/
/*if key == "" {*/
/*log.Warn().Interface("env", env).Msg("envのキーが空です")*/
/*continue*/
/*}*/

/*switch val := env.Value.(type) {*/
/*case string:*/
/*// スカラー文字列*/
/*expanded := utils.ExpandEnvVariables(val)*/
/*os.Setenv(key, expanded)*/

/*case []interface{}:*/
/*// 文字列の配列（interface{}スライス）*/
/*strVals := make([]string, 0, len(val))*/
/*for _, v := range val {*/
/*if s, ok := v.(string); ok {*/
/*strVals = append(strVals, utils.ExpandEnvVariables(s))*/
/*} else {*/
/*log.Warn().*/
/*Str("key", key).*/
/*Interface("element", v).*/
/*Msg("env配列の要素が文字列でない")*/
/*}*/
/*}*/

/*if strings.EqualFold(key, "Path") {*/
/*configPaths := strings.Join(strVals, separator)*/
/*newPaths := append(currentPaths, configPaths)*/
/*os.Setenv(key, strings.Join(newPaths, separator))*/
/*} else {*/

/*os.Setenv(key, strings.Join(strVals, separator))*/
/*}*/
/*default:*/
/*log.Warn().*/
/*Str("key", key).*/
/*Interface("value", env.Value).*/
/*Msg("envの値の型が未対応")*/
/*}*/
/*}*/

/*return nil*/
/*}*/

/*func (c *Config) BuildEnvs(baseEnv []string) []string {*/
/*envMap := make(map[string]string)*/

/*// baseEnv を map に変換*/
/*for _, e := range baseEnv {*/
/*parts := strings.SplitN(e, "=", 2)*/
/*if len(parts) == 2 {*/
/*envMap[strings.ToUpper(parts[0])] = parts[1]*/
/*}*/
/*}*/

/*separator := ";"*/
/*if runtime.GOOS != "windows" {*/
/*separator = ":"*/
/*}*/

/*for _, env := range c.Envs {*/
/*key := env.Key*/
/*if key == "" {*/
/*log.Warn().Interface("env", env).Msg("envのキーが空です")*/
/*continue*/
/*}*/

/*keyUpper := strings.ToUpper(key)*/

/*switch val := env.Value.(type) {*/
/*case string:*/
/*envMap[keyUpper] = utils.ExpandEnvVariables(val)*/

/*case []interface{}:*/
/*strVals := make([]string, 0, len(val))*/
/*for _, v := range val {*/
/*if s, ok := v.(string); ok {*/
/*strVals = append(strVals, utils.ExpandEnvVariables(s))*/
/*}*/
/*}*/

/*if keyUpper == "PATH" {*/
/*basePaths := []string{}*/
/*if existing, ok := envMap["PATH"]; ok {*/
/*basePaths = strings.Split(existing, separator)*/
/*}*/
/*// merged := append(basePaths, strVals...)*/
/*merged := append(strVals, basePaths...)*/
/*envMap["PATH"] = strings.Join(merged, separator)*/
/*} else {*/
/*envMap[keyUpper] = strings.Join(strVals, separator)*/
/*}*/
/*}*/
/*}*/

/*// map を []string に戻す*/
/*newEnv := make([]string, 0, len(envMap))*/
/*for k, v := range envMap {*/
/*newEnv = append(newEnv, k+"="+v)*/
/*}*/

/*return newEnv*/
/*}*/

/*func (c *Config) ApplyEnvs() error {*/
	/*// OSごとの区切り文字*/
	/*separator := ";"*/
	/*if runtime.GOOS != "windows" {*/
		/*separator = ":"*/
	/*}*/

	/*// 現在の環境を map に変換して重複チェック用*/
	/*envMap := make(map[string]map[string]struct{})*/
	/*for _, e := range os.Environ() {*/
		/*parts := strings.SplitN(e, "=", 2)*/
		/*if len(parts) != 2 {*/
			/*continue*/
		/*}*/
		/*key := strings.ToUpper(parts[0])*/
		/*val := parts[1]*/
		/*if _, ok := envMap[key]; !ok {*/
			/*envMap[key] = make(map[string]struct{})*/
		/*}*/
		/*envMap[key][val] = struct{}{}*/
	/*}*/

	/*for _, env := range c.Envs {*/
		/*key := strings.ToUpper(env.Key)*/
		/*if key == "" {*/
			/*log.Warn().Interface("env", env).Msg("envのキーが空です")*/
			/*continue*/
		/*}*/

		/*// string でも []interface{} でも統一して処理*/
		/*var strVals []string*/
		/*switch val := env.Value.(type) {*/
		/*case string:*/
			/*strVals = []string{general.ExpandEnvVariables(val)}*/
		/*case []interface{}:*/
			/*for _, v := range val {*/
				/*if s, ok := v.(string); ok {*/
					/*strVals = append(strVals, general.ExpandEnvVariables(s))*/
				/*}*/
			/*}*/
		/*default:*/
			/*log.Warn().Str("key", key).Interface("value", env.Value).Msg("envの値の型が未対応")*/
			/*continue*/
		/*}*/

		/*// 重複チェック用 map 初期化*/
		/*if _, ok := envMap[key]; !ok {*/
			/*envMap[key] = make(map[string]struct{})*/
		/*}*/

		/*// 重複しない値だけ追加*/
		/*for _, v := range strVals {*/
			/*if _, exists := envMap[key][v]; !exists {*/
				/*envMap[key][v] = struct{}{}*/
			/*}*/
		/*}*/

		/*// マップから文字列スライスに変換してセット*/
		/*newVals := make([]string, 0, len(envMap[key]))*/
		/*for val := range envMap[key] {*/
			/*newVals = append(newVals, val)*/
		/*}*/
		/*os.Setenv(key, strings.Join(newVals, separator))*/
	/*}*/

	/*return nil*/
/*}*/

